{"version":3,"sources":["components/ResizeGroup/ResizeGroup.tsx"],"names":[],"mappings":"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","file":"components/ResizeGroup/ResizeGroup.js","sourcesContent":["import * as React from 'react';\r\nimport {\r\n  css,\r\n  BaseComponent\r\n} from '../../Utilities';\r\nimport { IResizeGroupProps } from './ResizeGroup.Props';\r\nimport styles = require('./ResizeGroup.scss');\r\n\r\nconst RESIZE_DELAY = 16;\r\n\r\nexport interface IResizeGroupState {\r\n\r\n  /**\r\n   * Final data used to render proper sized component\r\n  */\r\n  renderedData?: any;\r\n\r\n  /**\r\n   * Data to render in a hidden div for measurement\r\n   */\r\n  dataToMeasure?: any;\r\n\r\n  /**\r\n   * Set to true when the content container might have new dimensions and should\r\n   * be remeasured.\r\n   */\r\n  measureContainer?: boolean;\r\n}\r\n\r\n/**\r\n * Returns a simple object is able to store measurements with a given key.\r\n */\r\nexport const getMeasurementCache = () => {\r\n  const measurementsCache: { [key: string]: number } = {};\r\n\r\n  return {\r\n    /**\r\n     * Checks if the provided data has a cacheKey. If it has a cacheKey and there is a\r\n     * corresponding entry in the measurementsCache, then it will return that value.\r\n     * Returns undefined otherwise.\r\n     */\r\n    getCachedMeasurement: (data: any): number | undefined => {\r\n      if (data && data.cacheKey && measurementsCache.hasOwnProperty(data.cacheKey)) {\r\n        return measurementsCache[data.cacheKey];\r\n      }\r\n\r\n      return undefined;\r\n    },\r\n    /**\r\n     * Should be called whenever there is a new measurement associated with a given data object.\r\n     * If the data has a cacheKey, store that measurement in the measurementsCache.\r\n     */\r\n    addMeasurementToCache: (data: any, measurement: number): void => {\r\n      if (data.cacheKey) {\r\n        measurementsCache[data.cacheKey] = measurement;\r\n      }\r\n    }\r\n  };\r\n};\r\n\r\n/**\r\n * Returns a function that is able to compute the next state for the ResizeGroup given the current\r\n * state and any measurement updates.\r\n */\r\nexport const getNextResizeGroupStateProvider = (measurementCache = getMeasurementCache()) => {\r\n  const _measurementCache = measurementCache;\r\n  let _containerWidth: number | undefined;\r\n\r\n  /**\r\n   * Gets the width of the data rendered in a hidden div.\r\n   * @param measuredData - The data corresponding to the measurement we wish to take.\r\n   * @param getElementToMeasureWidth - A function that returns the measurement of the rendered data. Only called when the measurement\r\n   * is not in the cache.\r\n   */\r\n  function _getMeasuredWidth(measuredData: any, getElementToMeasureWidth: () => number): number {\r\n    let cachedWidth = _measurementCache.getCachedMeasurement(measuredData);\r\n    if (cachedWidth !== undefined) {\r\n      return cachedWidth;\r\n    }\r\n\r\n    let measuredWidth = getElementToMeasureWidth();\r\n    _measurementCache.addMeasurementToCache(measuredData, measuredWidth);\r\n    return measuredWidth;\r\n  }\r\n\r\n  /**\r\n   * Will get the next IResizeGroupState based on the current data while trying to shrink contents\r\n   * to fit in the container.\r\n   * @param data - The initial data point to start measuring.\r\n   * @param onReduceData - Function that transforms the data into something that should render with less width.\r\n   * @param getElementToMeasureWidth - A function that returns the measurement of the rendered data. Only called when the measurement\r\n   * is not in the cache.\r\n   */\r\n  function _shrinkContentsUntilTheyFit(data: any,\r\n    onReduceData: (prevData: any) => any,\r\n    getElementToMeasureWidth: () => number): IResizeGroupState {\r\n    let dataToMeasure = data;\r\n    let measuredWidth = _getMeasuredWidth(data, getElementToMeasureWidth);\r\n\r\n    while (measuredWidth > _containerWidth) {\r\n      let nextMeasuredData = onReduceData(dataToMeasure);\r\n\r\n      // We don't want to get stuck in an infinite render loop when there are no more\r\n      // scaling steps, so implementations of onReduceData should return undefined when\r\n      // there are no more scaling states to apply.\r\n      if (nextMeasuredData === undefined) {\r\n        return {\r\n          renderedData: dataToMeasure,\r\n          dataToMeasure: undefined\r\n        };\r\n      }\r\n\r\n      measuredWidth = _measurementCache.getCachedMeasurement(nextMeasuredData);\r\n\r\n      // If the measurement isn't in the cache, we need to rerender with some data in a hidden div\r\n      if (measuredWidth === undefined) {\r\n        return {\r\n          dataToMeasure: nextMeasuredData\r\n        };\r\n      }\r\n\r\n      dataToMeasure = nextMeasuredData;\r\n    }\r\n\r\n    return {\r\n      renderedData: dataToMeasure,\r\n      dataToMeasure: undefined\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Handles an update to the container width. Should only be called when we knew the previous container width.\r\n   * @param newWidth - The new width of the container.\r\n   * @param fullWidthData - The initial data passed in as a prop to resizeGroup.\r\n   * @param renderedData - The data that was rendered prior to the container size changing.\r\n   */\r\n  function _updateContainerWidth(newWidth: number, fullWidthData: any, renderedData: any): IResizeGroupState {\r\n    let nextState: IResizeGroupState;\r\n    if (newWidth > _containerWidth) {\r\n      nextState = {\r\n        dataToMeasure: fullWidthData\r\n      };\r\n    } else {\r\n      nextState = {\r\n        dataToMeasure: renderedData\r\n      };\r\n    }\r\n    _containerWidth = newWidth;\r\n    return { ...nextState, measureContainer: false };\r\n  }\r\n\r\n  return (props: IResizeGroupProps,\r\n    currentState: IResizeGroupState,\r\n    getElementToMeasureWidth: () => number,\r\n    newContainerWidth?: number): IResizeGroupState | undefined => {\r\n    // If there is no new container width or data to measure, there is no need for a new state update\r\n    if (newContainerWidth === undefined && currentState.dataToMeasure === undefined) {\r\n      return undefined;\r\n    }\r\n\r\n    if (newContainerWidth) {\r\n      // If we know what the last container size was and we rendered data at that width, we can do an optimized render\r\n      if (_containerWidth && currentState.renderedData) {\r\n        return { ...currentState, ..._updateContainerWidth(newContainerWidth, props.data, currentState.renderedData) };\r\n      }\r\n\r\n      // If we are just setting the container width for the first time, we can't do any optimizations\r\n      _containerWidth = newContainerWidth;\r\n    }\r\n\r\n    let nextState: IResizeGroupState = {\r\n      ...currentState,\r\n      measureContainer: false\r\n    };\r\n\r\n    if (currentState.dataToMeasure) {\r\n      nextState = {\r\n        ...nextState,\r\n        ..._shrinkContentsUntilTheyFit(currentState.dataToMeasure, props.onReduceData, getElementToMeasureWidth)\r\n      };\r\n    }\r\n\r\n    return nextState;\r\n  };\r\n};\r\n\r\nexport class ResizeGroup extends BaseComponent<IResizeGroupProps, IResizeGroupState> {\r\n  private _getNextResizeGroupState = getNextResizeGroupStateProvider();\r\n  private _root: HTMLElement;\r\n  private _measured: HTMLElement;\r\n\r\n  constructor(props: IResizeGroupProps) {\r\n    super(props);\r\n    this.state = {\r\n      dataToMeasure: { ...this.props.data },\r\n      measureContainer: true,\r\n    };\r\n  }\r\n\r\n  public render() {\r\n    const { onRenderData, data } = this.props;\r\n    const { dataToMeasure, renderedData } = this.state;\r\n\r\n    return (\r\n      <div className={ css('ms-ResizeGroup') } ref={ this._resolveRef('_root') }>\r\n        { dataToMeasure && (\r\n          <div className={ css(styles.measured) } ref={ this._resolveRef('_measured') }>\r\n            { onRenderData(dataToMeasure) }\r\n          </div>\r\n        ) }\r\n\r\n        { renderedData && onRenderData(renderedData) }\r\n      </div>\r\n    );\r\n  }\r\n\r\n  public componentDidMount() {\r\n    this._afterComponentRendered();\r\n    this._events.on(window, 'resize', this._async.debounce(this._onResize, RESIZE_DELAY, { leading: true }));\r\n  }\r\n\r\n  public componentWillReceiveProps(nextProps: IResizeGroupProps) {\r\n    this.setState({\r\n      dataToMeasure: { ...nextProps.data },\r\n      renderedData: undefined,\r\n      measureContainer: true // Receiving new props means the parent might rerender and the root width might change\r\n    });\r\n  }\r\n\r\n  public componentDidUpdate(prevProps: IResizeGroupProps) {\r\n    if (this.state.renderedData) {\r\n      if (this.props.dataDidRender) {\r\n        this.props.dataDidRender(this.state.renderedData);\r\n      }\r\n    }\r\n    this._afterComponentRendered();\r\n  }\r\n\r\n  private _afterComponentRendered() {\r\n    let containerWidth = undefined;\r\n    if (this.state.measureContainer) {\r\n      containerWidth = this._root.getBoundingClientRect().width;\r\n    }\r\n    let nextState = this._getNextResizeGroupState(this.props,\r\n      this.state,\r\n      () => this._measured.getBoundingClientRect().width,\r\n      containerWidth);\r\n\r\n    if (nextState) {\r\n      this.setState(nextState);\r\n    }\r\n  }\r\n\r\n  private _onResize() {\r\n    if (this._root) {\r\n      this.setState({ measureContainer: true });\r\n    }\r\n  }\r\n}"],"sourceRoot":"..\\..\\..\\src"}